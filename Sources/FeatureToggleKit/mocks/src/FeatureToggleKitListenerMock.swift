//
// Updated on 11/12/25.
// Copyright Â© 2025. All rights reserved.///
/// @Generated by Mockolo
///

import FeatureToggleKit
import Foundation

// MARK: - FeatureToggleKitListenerMock

public final class FeatureToggleKitListenerMock: FeatureToggleKitListener, @unchecked Sendable {
  // MARK: Lifecycle

  public init() {}

  // MARK: Public

  public var didReceiveFeatureToggleUpdatesCallCount: Int {
    didReceiveFeatureToggleUpdatesState.withLock(\.callCount)
  }

  public var didReceiveFeatureToggleUpdatesHandler: (@Sendable ([(String, FeatureToggleValue)]) async -> Void)? {
    get { didReceiveFeatureToggleUpdatesState.withLock(\.handler) }
    set { didReceiveFeatureToggleUpdatesState.withLock { $0.handler = newValue } }
  }

  public var didReceiveErrorCallCount: Int {
    didReceiveErrorState.withLock(\.callCount)
  }

  public var didReceiveErrorHandler: (@Sendable (Error?) async -> Void)? {
    get { didReceiveErrorState.withLock(\.handler) }
    set { didReceiveErrorState.withLock { $0.handler = newValue } }
  }

  public func didReceiveFeatureToggleUpdates(values: [(String, FeatureToggleValue)]) async {
    let didReceiveFeatureToggleUpdatesHandler = didReceiveFeatureToggleUpdatesState.withLock { state in
      state.callCount += 1
      return state.handler
    }
    if let didReceiveFeatureToggleUpdatesHandler {
      await didReceiveFeatureToggleUpdatesHandler(values)
    }
  }

  public func didReceiveError(error: Error?) async {
    let didReceiveErrorHandler = didReceiveErrorState.withLock { state in
      state.callCount += 1
      return state.handler
    }
    if let didReceiveErrorHandler {
      await didReceiveErrorHandler(error)
    }
  }

  // MARK: Private

  private let didReceiveFeatureToggleUpdatesState = MockoloMutex(MockoloHandlerState<Never, @Sendable ([(String, FeatureToggleValue)]) async -> Void>())

  private let didReceiveErrorState = MockoloMutex(MockoloHandlerState<Never, @Sendable (Error?) async -> Void>())
}

private func warnIfNotSendable<each T>(function: String = #function, _: repeat each T) {
  print("At \(function), the captured arguments are not Sendable, it is not concurrency-safe.")
}

private func warnIfNotSendable<each T: Sendable>(function: String = #function, _: repeat each T) {}

// MARK: - MockoloMutex

/// Will be replaced to `Synchronization.Mutex` in future.
private final class MockoloMutex<Value>: @unchecked Sendable {
  // MARK: Lifecycle

  init(_ initialValue: Value) {
    value = initialValue
  }

  // MARK: Internal

  #if compiler(>=6.0)
  borrowing func withLock<Result, E: Error>(_ body: (inout sending Value) throws(E) -> Result) throws(E) -> sending Result {
    lock.lock()
    defer { lock.unlock() }
    return try body(&value)
  }
  #else
  func withLock<Result>(_ body: (inout Value) throws -> Result) rethrows -> Result {
    lock.lock()
    defer { lock.unlock() }
    return try body(&value)
  }
  #endif

  // MARK: Private

  private let lock = NSLock()
  private var value: Value
}

// MARK: - MockoloUnsafeTransfer

private struct MockoloUnsafeTransfer<Value>: @unchecked Sendable {
  // MARK: Lifecycle

  init(_ value: Value) {
    self.value = value
  }

  // MARK: Internal

  var value: Value
}

// MARK: - MockoloHandlerState

private struct MockoloHandlerState<Arg, Handler> {
  var argValues: [MockoloUnsafeTransfer<Arg>] = []
  var handler: Handler?
  var callCount = 0
}
